{"version":3,"sources":["../src/server.ts","../src/RouteGroup.ts","../src/engines/HttpEngine.ts","../src/engines/Http2Engine.ts"],"sourcesContent":["import { IEngine } from \"./interfaces/IEngine\";\r\nimport { IMiddleware } from \"./interfaces/IMiddleware\";\r\nimport { IRequest, HttpMethod } from \"./interfaces/IRequest\";\r\nimport type { IResponse } from \"./interfaces/IResponse\";\r\nimport { IRoute } from \"./interfaces/IRoute\";\r\nimport { IRouteGroup } from \"./interfaces/IRouteGroup\";\r\nimport { IServer } from \"./interfaces/IServer\";\r\n\r\nexport class Server implements IServer {\r\n  private _engine: IEngine;\r\n  private _globalMiddlewares: IMiddleware[] = [];\r\n  private _routes: IRoute[] = [];\r\n  private _isRunning: boolean = false;\r\n\r\n  constructor(engine: IEngine) {\r\n    this._engine = engine;\r\n    this.setupEngineHandler();\r\n  }\r\n\r\n  // Public readonly properties\r\n  public get isRunning(): boolean {\r\n    return this._isRunning;\r\n  }\r\n\r\n  public get engine(): IEngine {\r\n    return this._engine;\r\n  }\r\n\r\n  // Core server methods\r\n  public use(middleware: IMiddleware): Server {\r\n    this._globalMiddlewares.push(middleware);\r\n    return this;\r\n  }\r\n\r\n  public route(routeInput: IRoute | IRoute[] | IRouteGroup): Server {\r\n    if (this._isRunning) {\r\n      throw new Error('Cannot add routes after server has started');\r\n    }\r\n\r\n    if (this.isRouteGroup(routeInput)) {\r\n      this._routes.push(...routeInput.getPrefixedRoutes());\r\n    } else if (Array.isArray(routeInput)) {\r\n      this._routes.push(...routeInput);\r\n    } else {\r\n      this._routes.push(routeInput);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  public setEngine(engine: IEngine): Server {\r\n    if (this._isRunning) {\r\n      throw new Error('Cannot change engine while server is running');\r\n    }\r\n\r\n    this._engine = engine;\r\n    this.setupEngineHandler();\r\n    return this;\r\n  }\r\n\r\n  public async start(port: number, callback?: () => void): Promise<void> {\r\n    if (this._isRunning) {\r\n      throw new Error('Server is already running');\r\n    }\r\n\r\n    this._isRunning = true;\r\n\r\n    try {\r\n      await this._engine.listen(port, callback);\r\n      console.log(`Server started on port ${port} using ${this._engine.protocol}`);\r\n    } catch (error) {\r\n      this._isRunning = false;\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  public async stop(): Promise<void> {\r\n    if (!this._isRunning) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await this._engine.close();\r\n      this._isRunning = false;\r\n      console.log('Server stopped');\r\n    } catch (error) {\r\n      console.error('Error stopping server:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Private methods\r\n  private setupEngineHandler(): void {\r\n    this._engine.setRequestHandler(async (request: IRequest) => {\r\n      return await this.processRequest(request);\r\n    });\r\n  }\r\n\r\n  private async processRequest(request: IRequest): Promise<IResponse> {\r\n    try {\r\n      // Find matching route\r\n      const route = this.findRoute(request.method, request.path);\r\n\r\n      if (!route) {\r\n        return this.createErrorResponse(404, 'Not Found');\r\n      }\r\n\r\n      // Execute middleware chain + route handler\r\n      return await this.executeMiddlewareChain(route, request);\r\n    } catch (error: unknown) {\r\n      return await this.handleError(error, request);\r\n    }\r\n  }\r\n\r\n  private findRoute(method: HttpMethod, path: string): IRoute | undefined {\r\n    return this._routes.find(route => {\r\n      // Simple path matching - you'd want more sophisticated routing here\r\n      return route.method === method && this.pathMatches(route.path, path);\r\n    });\r\n  }\r\n\r\n  private pathMatches(routePath: string, requestPath: string): boolean {\r\n    // Basic exact match - enhance with parameter parsing\r\n    return routePath === requestPath;\r\n  }\r\n\r\n  private async executeMiddlewareChain(route: IRoute, request: IRequest): Promise<IResponse> {\r\n  const allMiddlewares = [...this._globalMiddlewares, ...route.middlewares];\r\n  const response = this.createResponse();\r\n\r\n  let index = 0;\r\n  const next = async (): Promise<void> => {\r\n    if (index >= allMiddlewares.length) {\r\n      await route.handler(request, response);\r\n      return;\r\n    }\r\n\r\n    const middleware = allMiddlewares[index++];\r\n\r\n    try {\r\n      if (middleware.before) {\r\n        await middleware.before(request, response, next);\r\n      } else {\r\n        await next();\r\n      }\r\n    } catch (error: unknown) {\r\n      if (middleware.onError) {\r\n        await middleware.onError(error, request, response, next);\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  };\r\n\r\n  await next();\r\n  return response;\r\n}\r\n\r\n  private async handleError(error: unknown, request: IRequest): Promise<IResponse> {\r\n    console.error('Request processing error:', error);\r\n\r\n    // Try to find error handling middleware\r\n    for (const middleware of this._globalMiddlewares) {\r\n      if (middleware.onError) {\r\n        const response = this.createResponse();\r\n        try {\r\n          await middleware.onError(error, request, response, () => Promise.resolve());\r\n          return response;\r\n        } catch {\r\n          // Error handler failed, continue to next\r\n        }\r\n      }\r\n    }\r\n\r\n    // No error handler handled it, return default error response\r\n    return this.createErrorResponse(500, 'Internal Server Error');\r\n  }\r\n\r\n  private createResponse(): IResponse {\r\n  let status: number | undefined; // Don't default to 200\r\n  let headers: Record<string, string> = {};\r\n  let body: unknown;\r\n  let sent: boolean = false;\r\n  let finished: boolean = false;\r\n\r\n  return {\r\n    get status(): number {\r\n      // If no status was explicitly set, default to 200 for successful responses\r\n      return status ?? 200;\r\n    },\r\n    get headers(): Record<string, string> { return { ...headers }; },\r\n    get body(): unknown { return body; },\r\n    get sent(): boolean { return sent; },\r\n    get finished(): boolean { return finished; },\r\n\r\n    setStatus(code: number): IResponse {\r\n      if (sent) {\r\n        throw new Error('Cannot set status after response has been sent');\r\n      }\r\n      status = code;\r\n      return this;\r\n    },\r\n\r\n    setHeader(name: string, value: string): IResponse {\r\n      if (sent) {\r\n        throw new Error('Cannot set headers after response has been sent');\r\n      }\r\n      headers[name] = value;\r\n      return this;\r\n    },\r\n\r\n    json(data: unknown): void {\r\n      this.setHeader('content-type', 'application/json');\r\n      this.send(data);\r\n    },\r\n\r\n    send(data?: unknown): void {\r\n      if (sent) {\r\n        throw new Error('Response has already been sent');\r\n      }\r\n\r\n      // If no status was set and we're sending data, assume 200\r\n      if (status === undefined) {\r\n        status = 200;\r\n      }\r\n\r\n      body = data;\r\n      sent = true;\r\n      finished = true;\r\n    }\r\n  };\r\n}\r\n\r\n  private createErrorResponse(status: number, message: string): IResponse {\r\n    const response = this.createResponse();\r\n    response.setStatus(status);\r\n    response.json({ error: message });\r\n    return response;\r\n  }\r\n\r\n  private isRouteGroup(input: any): input is IRouteGroup {\r\n    return input && typeof input === 'object' && 'getPrefixedRoutes' in input;\r\n  }\r\n}\r\n","import { IMiddleware } from \"./interfaces/IMiddleware\";\r\nimport { HttpMethod } from \"./interfaces/IRequest\";\r\nimport { IRoute } from \"./interfaces/IRoute\";\r\nimport { IRouteGroup } from \"./interfaces/IRouteGroup\";\r\n\r\nexport class RouteGroup implements IRouteGroup {\r\n  public readonly prefix: string;\r\n  public readonly routes: IRoute[];\r\n  public readonly middlewares: IMiddleware[];\r\n  public readonly description?: string;\r\n  public readonly tags?: string[];\r\n\r\n  constructor(\r\n    prefix: string,\r\n    routes: IRoute[],\r\n    middlewares: IMiddleware[] = [],\r\n    description?: string,\r\n    tags?: string[]\r\n  ) {\r\n    // Validate and normalize prefix\r\n    this.prefix = this.normalizePrefix(prefix);\r\n\r\n    // Store routes and middleware\r\n    this.routes = routes;\r\n    this.middlewares = middlewares;\r\n    this.description = description;\r\n    this.tags = tags;\r\n\r\n    // Validate route paths don't conflict with prefix\r\n    this.validateRoutes();\r\n  }\r\n\r\n  private normalizePrefix(prefix: string): string {\r\n    // Ensure prefix starts with / and doesn't end with /\r\n    if (!prefix.startsWith('/')) {\r\n      prefix = '/' + prefix;\r\n    }\r\n    if (prefix.length > 1 && prefix.endsWith('/')) {\r\n      prefix = prefix.slice(0, -1);\r\n    }\r\n    return prefix;\r\n  }\r\n\r\n  private validateRoutes(): void {\r\n    // Check for duplicate routes within the group\r\n    const routeKeys = new Set<string>();\r\n\r\n    for (const route of this.routes) {\r\n      const routeKey = `${route.method}:${this.prefix}${route.path}`;\r\n\r\n      if (routeKeys.has(routeKey)) {\r\n        throw new Error(`Duplicate route detected: ${routeKey}`);\r\n      }\r\n\r\n      routeKeys.add(routeKey);\r\n    }\r\n  }\r\n\r\n  // Method to add individual routes after creation\r\n  addRoute(route: IRoute): RouteGroup {\r\n    // Check for conflicts before adding\r\n    const routeKey = `${route.method}:${this.prefix}${route.path}`;\r\n    const existingRoute = this.routes.find(r => \r\n      `${r.method}:${this.prefix}${r.path}` === routeKey\r\n    );\r\n\r\n    if (existingRoute) {\r\n      throw new Error(`Route already exists: ${routeKey}`);\r\n    }\r\n\r\n    return new RouteGroup(\r\n      this.prefix,\r\n      [...this.routes, route],\r\n      this.middlewares,\r\n      this.description,\r\n      this.tags\r\n    );\r\n  }\r\n\r\n  // Method to add middleware after creation\r\n  use(middleware: IMiddleware): RouteGroup {\r\n    return new RouteGroup(\r\n      this.prefix,\r\n      this.routes,\r\n      [...this.middlewares, middleware],\r\n      this.description,\r\n      this.tags\r\n    );\r\n  }\r\n\r\n  // Method to get all routes with prefixed paths\r\n  getPrefixedRoutes(): IRoute[] {\r\n    return this.routes.map(route => ({\r\n      ...route,\r\n      path: this.prefix + route.path,\r\n      middlewares: [...this.middlewares, ...route.middlewares]\r\n    }));\r\n  }\r\n\r\n  // Method to find a specific route\r\n  findRoute(method: HttpMethod, path: string): IRoute | undefined {\r\n    return this.routes.find(route => \r\n      route.method === method && route.path === path\r\n    );\r\n  }\r\n\r\n  // Method to get route count\r\n  get routeCount(): number {\r\n    return this.routes.length;\r\n  }\r\n\r\n  // Method to check if group has specific tag\r\n  hasTag(tag: string): boolean {\r\n    return this.tags?.includes(tag) ?? false;\r\n  }\r\n}","import * as http from 'http';\r\nimport * as url from 'url';\r\nimport { IEngine, IRequest, IResponse, HttpMethod } from '../interfaces';\r\n\r\ninterface HttpOptions {\r\n  maxConnections?: number;\r\n  timeout?: number;\r\n  keepAlive?: boolean;\r\n  keepAliveTimeout?: number;\r\n}\r\n\r\nexport class HttpEngine implements IEngine {\r\n  public readonly protocol = 'HTTP/1.1';\r\n  public readonly isSecure = false;\r\n\r\n  private server: http.Server;\r\n  private requestHandler?: (request: IRequest) => Promise<IResponse>;\r\n\r\n  constructor(options: HttpOptions = {}) {\r\n    // Default options for HTTP/1.1\r\n    const defaultOptions: HttpOptions = {\r\n      maxConnections: 1000,\r\n      timeout: 30000,\r\n      keepAlive: true,\r\n      keepAliveTimeout: 5000,\r\n      ...options\r\n    };\r\n\r\n    this.server = http.createServer(defaultOptions);\r\n    this.setupRequestHandler();\r\n  }\r\n\r\n  private setupRequestHandler(): void {\r\n    this.server.on('request', async (req: http.IncomingMessage, res: http.ServerResponse) => {\r\n      try {\r\n        // Convert HTTP/1 request to framework IRequest\r\n        const request = await this.createRequestFromHttp(req);\r\n\r\n        // Process request through framework handler\r\n        if (this.requestHandler) {\r\n          const response = await this.requestHandler(request);\r\n\r\n          // Send response back through HTTP/1\r\n          await this.sendResponse(res, response);\r\n        } else {\r\n          // No handler configured, send 501\r\n          res.writeHead(501, { 'Content-Type': 'text/plain' });\r\n          res.end('Not Implemented');\r\n        }\r\n      } catch (error: unknown) {\r\n        console.error('HTTP/1 Request Error:', error);\r\n\r\n        // Type-safe error handling\r\n        const errorMessage = this.getErrorMessage(error);\r\n\r\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\r\n        res.end(errorMessage);\r\n      }\r\n    });\r\n\r\n    // Handle server errors\r\n    this.server.on('error', (error: Error) => {\r\n      console.error('HTTP/1 Server Error:', error);\r\n    });\r\n  }\r\n\r\n private async createRequestFromHttp(req: http.IncomingMessage): Promise<IRequest> {\r\n  // Parse URL to extract components\r\n  const parsedUrl = url.parse(req.url || '/', true);\r\n\r\n  // Convert string to HttpMethod\r\n  const method: HttpMethod = this.normalizeHttpMethod(req.method || 'GET');\r\n\r\n  // Create a proper URL object from the parsed URL\r\n  const requestUrl = new URL(\r\n    `${req.headers['x-forwarded-proto'] || 'http'}://${req.headers.host || 'localhost'}${req.url || '/'}`\r\n  );\r\n\r\n  // Extract query parameters\r\n  const query: Record<string, string> = {};\r\n  Object.entries(parsedUrl.query).forEach(([key, value]) => {\r\n    query[key] = Array.isArray(value) ? value[0] : (value as string);\r\n  });\r\n\r\n  // Extract route parameters (simplified - you'd want more sophisticated path parsing)\r\n  const params: Record<string, string> = {};\r\n\r\n  // Convert HTTP/1 headers to standard format\r\n  const requestHeaders: Record<string, string> = {};\r\n  Object.entries(req.headers).forEach(([key, value]) => {\r\n    if (typeof value === 'string') {\r\n      requestHeaders[key] = value;\r\n    } else if (Array.isArray(value)) {\r\n      requestHeaders[key] = value[0];\r\n    }\r\n  });\r\n\r\n  // Parse body (HTTP/1 requests are readable streams)\r\n  let body: unknown = undefined;\r\n  const chunks: Buffer[] = [];\r\n\r\n  return new Promise<IRequest>((resolve) => {\r\n    req.on('data', (chunk: Buffer) => {\r\n      chunks.push(chunk);\r\n    });\r\n\r\n    req.on('end', () => {\r\n      if (chunks.length > 0) {\r\n        const rawBody = Buffer.concat(chunks).toString();\r\n\r\n        // Try to parse as JSON, fall back to raw string\r\n        try {\r\n          body = JSON.parse(rawBody);\r\n        } catch {\r\n          body = rawBody;\r\n        }\r\n      }\r\n\r\n      resolve({\r\n        method,\r\n        url: requestUrl, // Now using proper URL object\r\n        path: parsedUrl.pathname || '/',\r\n        headers: requestHeaders,\r\n        query,\r\n        params,\r\n        body,\r\n        protocol: this.protocol,\r\n        remoteAddress: req.socket.remoteAddress,\r\n        userAgent: requestHeaders['user-agent']\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\n\r\n  private async sendResponse(res: http.ServerResponse, response: IResponse): Promise<void> {\r\n    // Set status code\r\n    res.statusCode = response.status || 200;\r\n\r\n    // Set headers\r\n    Object.entries(response.headers || {}).forEach(([name, value]) => {\r\n      res.setHeader(name, value);\r\n    });\r\n\r\n    // Send body if present\r\n    if (response.body !== undefined) {\r\n      if (typeof response.body === 'string') {\r\n        res.write(response.body);\r\n      } else if (Buffer.isBuffer(response.body)) {\r\n        res.write(response.body);\r\n      } else {\r\n        // Convert objects to JSON\r\n        const jsonString = JSON.stringify(response.body);\r\n\r\n        // Set content-type if not already set\r\n        if (!response.headers?.['content-type']) {\r\n          res.setHeader('Content-Type', 'application/json');\r\n        }\r\n\r\n        res.write(jsonString);\r\n      }\r\n    }\r\n\r\n    // End the response\r\n    res.end();\r\n  }\r\n\r\n  private normalizeHttpMethod(method: string): HttpMethod {\r\n    const upperMethod = method.toUpperCase();\r\n\r\n    // Validate that it's a valid HttpMethod\r\n    const validMethods: HttpMethod[] = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'];\r\n\r\n    if (!validMethods.includes(upperMethod as HttpMethod)) {\r\n      throw new Error(`Unsupported HTTP method: ${method}`);\r\n    }\r\n\r\n    return upperMethod as HttpMethod;\r\n  }\r\n\r\n  private getErrorMessage(error: unknown): string {\r\n    if (error instanceof Error) {\r\n      return error.message;\r\n    }\r\n\r\n    if (typeof error === 'string') {\r\n      return error;\r\n    }\r\n\r\n    // Handle other unknown error types\r\n    try {\r\n      return JSON.stringify(error);\r\n    } catch {\r\n      return 'Unknown error occurred';\r\n    }\r\n  }\r\n\r\n  async listen(port: number, callback?: () => void): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      try {\r\n        this.server.listen(port, () => {\r\n          console.log(`HTTP/1.1 server listening on port ${port}`);\r\n          callback?.();\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      try {\r\n        this.server.close((error?: Error) => {\r\n          if (error) {\r\n            reject(error);\r\n          } else {\r\n            console.log('HTTP/1.1 server closed');\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  setRequestHandler(handler: (request: IRequest) => Promise<IResponse>): void {\r\n    this.requestHandler = handler;\r\n  }\r\n}\r\n","import * as http2 from 'http2';\r\nimport { HttpMethod, IRequest } from '../interfaces/IRequest';\r\nimport { IEngine } from '../interfaces/IEngine';\r\nimport type { IResponse } from '../interfaces/IResponse';\r\n\r\ninterface Http2Options {\r\n  key?: string | Buffer;\r\n  cert?: string | Buffer;\r\n  allowHTTP1?: boolean;\r\n  maxConnections?: number;\r\n  timeout?: number;\r\n}\r\n\r\nexport class Http2Engine implements IEngine {\r\n  public readonly protocol = 'HTTP/2';\r\n  public readonly isSecure = true;\r\n\r\n  private server: http2.Http2SecureServer;\r\n  private requestHandler?: (request: IRequest) => Promise<IResponse>;\r\n\r\n  constructor(options: Http2Options = {}) {\r\n    // Default options for secure HTTP2\r\n    const defaultOptions: Http2Options = {\r\n      allowHTTP1: true, // Fallback to HTTP/1.1\r\n      maxConnections: 1000,\r\n      timeout: 30000,\r\n      ...options\r\n    };\r\n\r\n    // Validate required SSL options for secure HTTP2\r\n    if (!defaultOptions.key || !defaultOptions.cert) {\r\n      throw new Error('HTTP/2 requires SSL certificate and key. Provide key and cert options.');\r\n    }\r\n\r\n    this.server = http2.createSecureServer(defaultOptions);\r\n    this.setupStreamHandler();\r\n  }\r\n\r\n  private setupStreamHandler(): void {\r\n    this.server.on('stream', async (stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) => {\r\n      try {\r\n        // Convert HTTP2 headers to framework IRequest\r\n        const request = await this.createRequestFromHeaders(headers, stream);\r\n\r\n        // Process request through framework handler\r\n        if (this.requestHandler) {\r\n          const response = await this.requestHandler(request);\r\n\r\n          // Send response back through HTTP2 stream\r\n          await this.sendResponse(stream, response);\r\n        } else {\r\n          // No handler configured, send 501\r\n          stream.respond({ ':status': 501 });\r\n          stream.end('Not Implemented');\r\n        }\r\n      } catch (error: unknown) {\r\n        console.error('HTTP2 Stream Error:', error);\r\n\r\n        // Type-safe error handling\r\n        const errorMessage = this.getErrorMessage(error);\r\n\r\n        stream.respond({ ':status': 500 });\r\n        stream.end(errorMessage);\r\n      }\r\n    });\r\n\r\n    // Handle server errors\r\n    this.server.on('error', (error: Error) => {\r\n      console.error('HTTP2 Server Error:', error);\r\n    });\r\n  }\r\n\r\n  private getErrorMessage(error: unknown): string {\r\n    if (error instanceof Error) {\r\n      return error.message;\r\n    }\r\n\r\n    if (typeof error === 'string') {\r\n      return error;\r\n    }\r\n\r\n    // Handle other unknown error types\r\n    try {\r\n      return JSON.stringify(error);\r\n    } catch {\r\n      return 'Unknown error occurred';\r\n    }\r\n  }\r\n\r\n  private async createRequestFromHeaders(headers: http2.IncomingHttpHeaders, stream: http2.ServerHttp2Stream): Promise<IRequest> {\r\n    // Extract HTTP2 pseudo-headers\r\n    const methodString = (headers[':method'] as string) || 'GET';\r\n    const path = (headers[':path'] as string) || '/';\r\n    const scheme = (headers[':scheme'] as string) || 'https';\r\n    const authority = (headers[':authority'] as string) || 'localhost';\r\n\r\n    // Convert string to HttpMethod\r\n    const method: HttpMethod = this.normalizeHttpMethod(methodString);\r\n\r\n    // Parse URL components\r\n    const url = new URL(`${scheme}://${authority}${path}`);\r\n\r\n    // Extract query parameters\r\n    const query: Record<string, string> = {};\r\n    url.searchParams.forEach((value, key) => {\r\n      query[key] = value;\r\n    });\r\n\r\n    // Extract route parameters (simplified - you'd want more sophisticated path parsing)\r\n    const params: Record<string, string> = {};\r\n\r\n    // Convert HTTP2 headers to standard format (HTTP2 uses lowercase)\r\n    const requestHeaders: Record<string, string> = {};\r\n    Object.entries(headers).forEach(([key, value]) => {\r\n      if (!key.startsWith(':') && typeof value === 'string') {\r\n        requestHeaders[key] = value;\r\n      }\r\n    });\r\n\r\n    // Parse body (HTTP2 streams are readable)\r\n    let body: unknown = undefined;\r\n    const chunks: Buffer[] = [];\r\n\r\n    return new Promise<IRequest>((resolve) => {\r\n      stream.on('data', (chunk: Buffer) => {\r\n        chunks.push(chunk);\r\n      });\r\n\r\n      stream.on('end', () => {\r\n        if (chunks.length > 0) {\r\n          const rawBody = Buffer.concat(chunks).toString();\r\n\r\n          // Try to parse as JSON, fall back to raw string\r\n          try {\r\n            body = JSON.parse(rawBody);\r\n          } catch {\r\n            body = rawBody;\r\n          }\r\n        }\r\n\r\n        resolve({\r\n          method,\r\n          url,\r\n          path: url.pathname,\r\n          headers: requestHeaders,\r\n          query,\r\n          params,\r\n          body,\r\n          protocol: this.protocol,\r\n          remoteAddress: stream.session?.socket?.remoteAddress,\r\n          userAgent: requestHeaders['user-agent']\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  private normalizeHttpMethod(method: string): HttpMethod {\r\n    const upperMethod = method.toUpperCase();\r\n\r\n    // Validate that it's a valid HttpMethod\r\n    const validMethods: HttpMethod[] = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'];\r\n\r\n    if (!validMethods.includes(upperMethod as HttpMethod)) {\r\n      throw new Error(`Unsupported HTTP method: ${method}`);\r\n    }\r\n\r\n    return upperMethod as HttpMethod;\r\n  }\r\n\r\n  private async sendResponse(stream: http2.ServerHttp2Stream, response: IResponse): Promise<void> {\r\n    // Convert framework IResponse to HTTP2 headers\r\n    const http2Headers: http2.OutgoingHttpHeaders = {\r\n      ':status': response.status || 200,\r\n      ...response.headers\r\n    };\r\n\r\n    // Respond with headers\r\n    stream.respond(http2Headers);\r\n\r\n    // Send body if present\r\n    if (response.body !== undefined) {\r\n      if (typeof response.body === 'string') {\r\n        stream.write(response.body);\r\n      } else if (Buffer.isBuffer(response.body)) {\r\n        stream.write(response.body);\r\n      } else {\r\n        // Convert objects to JSON\r\n        stream.write(JSON.stringify(response.body));\r\n\r\n        // Set content-type if not already set\r\n        if (!response.headers['content-type']) {\r\n          stream.respond({ ':status': response.status || 200, 'content-type': 'application/json' });\r\n        }\r\n      }\r\n    }\r\n\r\n    // End the stream\r\n    stream.end();\r\n  }\r\n\r\n  async listen(port: number, callback?: () => void): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      try {\r\n        this.server.listen(port, () => {\r\n          console.log(`HTTP/2 server listening on port ${port}`);\r\n          callback?.();\r\n          resolve();\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  async close(): Promise<void> {\r\n    return new Promise<void>((resolve, reject) => {\r\n      try {\r\n        this.server.close((error?: Error) => {\r\n          if (error) {\r\n            reject(error);\r\n          } else {\r\n            console.log('HTTP/2 server closed');\r\n            resolve();\r\n          }\r\n        });\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  setRequestHandler(handler: (request: IRequest) => Promise<IResponse>): void {\r\n    this.requestHandler = handler;\r\n  }\r\n}\r\n"],"mappings":"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","names":["url"]}