{"version":3,"sources":["../src/server.ts","../src/RouteGroup.ts","../src/engines/HttpEngine.ts","../src/engines/Http2Engine.ts"],"sourcesContent":["import { IEngine } from './interfaces/IEngine';\nimport { IMiddleware } from './interfaces/IMiddleware';\nimport { IRequest, HttpMethod } from './interfaces/IRequest';\nimport type { IResponse } from './interfaces/IResponse';\nimport { IRoute } from './interfaces/IRoute';\nimport { IRouteGroup } from './interfaces/IRouteGroup';\nimport { IServer } from './interfaces/IServer';\n\nexport class Server implements IServer {\n  private _engine: IEngine;\n  private _globalMiddlewares: IMiddleware[] = [];\n  private _routes: IRoute[] = [];\n  private _isRunning: boolean = false;\n\n  constructor(engine: IEngine) {\n    this._engine = engine;\n    this.setupEngineHandler();\n  }\n\n  // Public readonly properties\n  public get isRunning(): boolean {\n    return this._isRunning;\n  }\n\n  public get engine(): IEngine {\n    return this._engine;\n  }\n\n  // Core server methods\n  public use(middleware: IMiddleware): Server {\n    this._globalMiddlewares.push(middleware);\n    return this;\n  }\n\n  public route(routeInput: IRoute | IRoute[] | IRouteGroup): Server {\n    if (this._isRunning) {\n      throw new Error('Cannot add routes after server has started');\n    }\n\n    if (this.isRouteGroup(routeInput)) {\n      this._routes.push(...routeInput.getPrefixedRoutes());\n    } else if (Array.isArray(routeInput)) {\n      routeInput.forEach(route => {\n        if (route.path === '') {\n          route.path = '/';\n        }\n      });\n      this._routes.push(...routeInput);\n    } else {\n      if (routeInput.path === '') {\n        routeInput.path = '/';\n      }\n      this._routes.push(routeInput);\n    }\n\n    return this;\n  }\n\n  public setEngine(engine: IEngine): Server {\n    if (this._isRunning) {\n      throw new Error('Cannot change engine while server is running');\n    }\n\n    this._engine = engine;\n    this.setupEngineHandler();\n    return this;\n  }\n\n  public async start(port: number, callback?: () => void): Promise<void> {\n    if (this._isRunning) {\n      throw new Error('Server is already running');\n    }\n\n    this._isRunning = true;\n\n    try {\n      await this._engine.listen(port, callback);\n      console.log(`Server started on port ${port} using ${this._engine.protocol}`);\n      for (const route of this._routes) {\n        console.log(`Registered route: [${route.method}] ${route.path}`);\n      }\n    } catch (error) {\n      this._isRunning = false;\n      throw error;\n    }\n  }\n\n  public async stop(): Promise<void> {\n    if (!this._isRunning) {\n      return;\n    }\n\n    try {\n      await this._engine.close();\n      this._isRunning = false;\n      console.log('Server stopped');\n    } catch (error) {\n      console.error('Error stopping server:', error);\n      throw error;\n    }\n  }\n\n  // Private methods\n  private setupEngineHandler(): void {\n    this._engine.setRequestHandler(async (request: IRequest) => {\n      return await this.processRequest(request);\n    });\n  }\n\n  private async processRequest(request: IRequest): Promise<IResponse> {\n    try {\n      // Find matching route\n      const route = this.findRoute(request.method, request.path);\n\n      if (!route) {\n        return this.createErrorResponse(404, 'Not Found');\n      }\n\n      // Execute middleware chain + route handler\n      return await this.executeMiddlewareChain(route, request);\n    } catch (error: unknown) {\n      return await this.handleError(error, request);\n    }\n  }\n\n  private findRoute(method: HttpMethod, path: string): IRoute | undefined {\n    return this._routes.find(route => {\n      // Simple path matching - you'd want more sophisticated routing here\n      return route.method === method && this.pathMatches(route.path, path);\n    });\n  }\n\n  private pathMatches(routePath: string, requestPath: string): boolean {\n    // Basic exact match - enhance with parameter parsing\n    return routePath === requestPath;\n  }\n\n  private async executeMiddlewareChain(route: IRoute, request: IRequest): Promise<IResponse> {\n    const allMiddlewares = [...this._globalMiddlewares, ...(route.middlewares ?? [])];\n    const response = this.createResponse();\n\n    let index = 0;\n    const next = async (): Promise<void> => {\n      if (index >= allMiddlewares.length) {\n        await route.handler(request, response);\n        return;\n      }\n\n      const middleware = allMiddlewares[index++];\n\n      try {\n        if (middleware.before) {\n          await middleware.before(request, response, next);\n        } else {\n          await next();\n        }\n      } catch (error: unknown) {\n        if (middleware.onError) {\n          await middleware.onError(error, request, response, next);\n        } else {\n          throw error;\n        }\n      }\n    };\n\n    await next();\n    return response;\n  }\n\n  private async handleError(error: unknown, request: IRequest): Promise<IResponse> {\n    console.error('Request processing error:', error);\n\n    // Try to find error handling middleware\n    for (const middleware of this._globalMiddlewares) {\n      if (middleware.onError) {\n        const response = this.createResponse();\n        try {\n          await middleware.onError(error, request, response, () => Promise.resolve());\n          return response;\n        } catch {\n          // Error handler failed, continue to next\n        }\n      }\n    }\n\n    // No error handler handled it, return default error response\n    return this.createErrorResponse(500, 'Internal Server Error');\n  }\n\n  private createResponse(): IResponse {\n    let status: number | undefined; // Don't default to 200\n    let headers: Record<string, string> = {};\n    let body: unknown;\n    let sent: boolean = false;\n    let finished: boolean = false;\n\n    return {\n      get status(): number {\n        // If no status was explicitly set, default to 200 for successful responses\n        return status ?? 200;\n      },\n      get headers(): Record<string, string> {\n        return { ...headers };\n      },\n      get body(): unknown {\n        return body;\n      },\n      get sent(): boolean {\n        return sent;\n      },\n      get finished(): boolean {\n        return finished;\n      },\n\n      setStatus(code: number): IResponse {\n        if (sent) {\n          throw new Error('Cannot set status after response has been sent');\n        }\n        status = code;\n        return this;\n      },\n\n      setHeader(name: string, value: string): IResponse {\n        if (sent) {\n          throw new Error('Cannot set headers after response has been sent');\n        }\n        headers[name] = value;\n        return this;\n      },\n\n      json(data: unknown): void {\n        this.setHeader('content-type', 'application/json');\n        this.send(data);\n      },\n\n      send(data?: unknown): void {\n        if (sent) {\n          throw new Error('Response has already been sent');\n        }\n\n        // If no status was set and we're sending data, assume 200\n        if (status === undefined) {\n          status = 200;\n        }\n\n        body = data;\n        sent = true;\n        finished = true;\n      },\n    };\n  }\n\n  private createErrorResponse(status: number, message: string): IResponse {\n    const response = this.createResponse();\n    response.setStatus(status);\n    response.json({ error: message });\n    return response;\n  }\n\n  private isRouteGroup(input: any): input is IRouteGroup {\n    return input && typeof input === 'object' && 'getPrefixedRoutes' in input;\n  }\n}\n","import { IMiddleware } from './interfaces/IMiddleware';\nimport { HttpMethod } from './interfaces/IRequest';\nimport { IRoute } from './interfaces/IRoute';\nimport { IRouteGroup } from './interfaces/IRouteGroup';\n\nexport class RouteGroup implements IRouteGroup {\n  public readonly prefix: string;\n  public readonly routes: IRoute[];\n  public readonly middlewares: IMiddleware[];\n  public readonly description?: string;\n  public readonly tags?: string[];\n\n  constructor(\n    prefix: string,\n    routes: IRoute[],\n    middlewares: IMiddleware[] = [],\n    description?: string,\n    tags?: string[]\n  ) {\n    // Validate and normalize prefix\n    this.prefix = this.normalizePrefix(prefix);\n\n    // Store routes and middleware\n    this.routes = routes;\n    this.middlewares = middlewares;\n    this.description = description;\n    this.tags = tags;\n\n    // Validate route paths don't conflict with prefix\n    this.validateRoutes();\n  }\n\n  private normalizePrefix(prefix: string): string {\n    // Ensure prefix starts with / and doesn't end with /\n    if (!prefix.startsWith('/')) {\n      prefix = '/' + prefix;\n    }\n    if (prefix.length > 1 && prefix.endsWith('/')) {\n      prefix = prefix.slice(0, -1);\n    }\n    return prefix;\n  }\n\n  private validateRoutes(): void {\n    // Check for duplicate routes within the group\n    const routeKeys = new Set<string>();\n\n    for (const route of this.routes) {\n      const routeKey = `${route.method}:${this.prefix}${route.path}`;\n\n      if (routeKeys.has(routeKey)) {\n        throw new Error(`Duplicate route detected: ${routeKey}`);\n      }\n\n      routeKeys.add(routeKey);\n    }\n  }\n\n  // Method to add individual routes after creation\n  public addRoute(route: IRoute): RouteGroup {\n    // Check for conflicts before adding\n    const routeKey = `${route.method}:${this.prefix}${route.path}`;\n    const existingRoute = this.routes.find(r => `${r.method}:${this.prefix}${r.path}` === routeKey);\n\n    if (existingRoute) {\n      throw new Error(`Route already exists: ${routeKey}`);\n    }\n\n    return new RouteGroup(\n      this.prefix,\n      [...this.routes, route],\n      this.middlewares,\n      this.description,\n      this.tags\n    );\n  }\n\n  // Method to add middleware after creation\n  public use(middleware: IMiddleware): RouteGroup {\n    return new RouteGroup(\n      this.prefix,\n      this.routes,\n      [...this.middlewares, middleware],\n      this.description,\n      this.tags\n    );\n  }\n\n  // Method to get all routes with prefixed paths\n  public getPrefixedRoutes(): IRoute[] {\n    return this.routes.map(route => ({\n      ...route,\n      path: this.prefix + route.path,\n      middlewares: [...this.middlewares, ...(route.middlewares || [])],\n    }));\n  }\n\n  // Method to find a specific route\n  public findRoute(method: HttpMethod, path: string): IRoute | undefined {\n    return this.routes.find(route => route.method === method && route.path === path);\n  }\n\n  // Method to get route count\n  get routeCount(): number {\n    return this.routes.length;\n  }\n\n  // Method to check if group has specific tag\n  public hasTag(tag: string): boolean {\n    return this.tags?.includes(tag) ?? false;\n  }\n}\n","import * as http from 'http';\nimport * as url from 'url';\nimport { IEngine, IRequest, IResponse, HttpMethod } from '../interfaces';\n\ninterface HttpOptions {\n  maxConnections?: number;\n  timeout?: number;\n  keepAlive?: boolean;\n  keepAliveTimeout?: number;\n}\n\nexport class HttpEngine implements IEngine {\n  public readonly protocol = 'HTTP/1.1';\n  public readonly isSecure = false;\n\n  private server: http.Server;\n  private requestHandler?: (request: IRequest) => Promise<IResponse>;\n\n  constructor(options: HttpOptions = {}) {\n    // Default options for HTTP/1.1\n    const defaultOptions: HttpOptions = {\n      maxConnections: 1000,\n      timeout: 30000,\n      keepAlive: true,\n      keepAliveTimeout: 5000,\n      ...options,\n    };\n\n    this.server = http.createServer(defaultOptions);\n    this.setupRequestHandler();\n  }\n\n  private setupRequestHandler(): void {\n    this.server.on('request', async (req: http.IncomingMessage, res: http.ServerResponse) => {\n      try {\n        // Convert HTTP/1 request to framework IRequest\n        const request = await this.createRequestFromHttp(req);\n\n        // Process request through framework handler\n        if (this.requestHandler) {\n          const response = await this.requestHandler(request);\n\n          // Send response back through HTTP/1\n          await this.sendResponse(res, response);\n        } else {\n          // No handler configured, send 501\n          res.writeHead(501, { 'Content-Type': 'text/plain' });\n          res.end('Not Implemented');\n        }\n      } catch (error: unknown) {\n        console.error('HTTP/1 Request Error:', error);\n\n        // Type-safe error handling\n        const errorMessage = this.getErrorMessage(error);\n\n        res.writeHead(500, { 'Content-Type': 'text/plain' });\n        res.end(errorMessage);\n      }\n    });\n\n    // Handle server errors\n    this.server.on('error', (error: Error) => {\n      console.error('HTTP/1 Server Error:', error);\n    });\n  }\n\n  private async createRequestFromHttp(req: http.IncomingMessage): Promise<IRequest> {\n    // Parse URL to extract components\n    const parsedUrl = url.parse(req.url || '/', true);\n\n    // Convert string to HttpMethod\n    const method: HttpMethod = this.normalizeHttpMethod(req.method || 'GET');\n\n    // Create a proper URL object from the parsed URL\n    const requestUrl = new URL(\n      `${req.headers['x-forwarded-proto'] || 'http'}://${req.headers.host || 'localhost'}${req.url || '/'}`\n    );\n\n    // Extract query parameters\n    const query: Record<string, string> = {};\n    Object.entries(parsedUrl.query).forEach(([key, value]) => {\n      query[key] = Array.isArray(value) ? value[0] : (value as string);\n    });\n\n    // Extract route parameters (simplified - you'd want more sophisticated path parsing)\n    const params: Record<string, string> = {};\n\n    // Convert HTTP/1 headers to standard format\n    const requestHeaders: Record<string, string> = {};\n    Object.entries(req.headers).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        requestHeaders[key] = value;\n      } else if (Array.isArray(value)) {\n        requestHeaders[key] = value[0];\n      }\n    });\n\n    // Parse body (HTTP/1 requests are readable streams)\n    let body: unknown = undefined;\n    const chunks: Buffer[] = [];\n\n    return new Promise<IRequest>(resolve => {\n      req.on('data', (chunk: Buffer) => {\n        chunks.push(chunk);\n      });\n\n      req.on('end', () => {\n        if (chunks.length > 0) {\n          const rawBody = Buffer.concat(chunks).toString();\n\n          // Try to parse as JSON, fall back to raw string\n          try {\n            body = JSON.parse(rawBody);\n          } catch {\n            body = rawBody;\n          }\n        }\n\n        resolve({\n          method,\n          url: requestUrl, // Now using proper URL object\n          path: parsedUrl.pathname || '/',\n          headers: requestHeaders,\n          query,\n          params,\n          body,\n          protocol: this.protocol,\n          remoteAddress: req.socket.remoteAddress,\n          userAgent: requestHeaders['user-agent'],\n        });\n      });\n    });\n  }\n\n  private async sendResponse(res: http.ServerResponse, response: IResponse): Promise<void> {\n    // Set status code\n    res.statusCode = response.status || 200;\n\n    // Set headers\n    Object.entries(response.headers || {}).forEach(([name, value]) => {\n      res.setHeader(name, value);\n    });\n\n    // Send body if present\n    if (response.body !== undefined) {\n      if (typeof response.body === 'string') {\n        res.write(response.body);\n      } else if (Buffer.isBuffer(response.body)) {\n        res.write(response.body);\n      } else {\n        // Convert objects to JSON\n        const jsonString = JSON.stringify(response.body);\n\n        // Set content-type if not already set\n        if (!response.headers?.['content-type']) {\n          res.setHeader('Content-Type', 'application/json');\n        }\n\n        res.write(jsonString);\n      }\n    }\n\n    // End the response\n    res.end();\n  }\n\n  private normalizeHttpMethod(method: string): HttpMethod {\n    const upperMethod = method.toUpperCase();\n\n    // Validate that it's a valid HttpMethod\n    const validMethods: HttpMethod[] = [\n      'GET',\n      'POST',\n      'PUT',\n      'PATCH',\n      'DELETE',\n      'HEAD',\n      'OPTIONS',\n      'TRACE',\n      'CONNECT',\n    ];\n\n    if (!validMethods.includes(upperMethod as HttpMethod)) {\n      throw new Error(`Unsupported HTTP method: ${method}`);\n    }\n\n    return upperMethod as HttpMethod;\n  }\n\n  private getErrorMessage(error: unknown): string {\n    if (error instanceof Error) {\n      return error.message;\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    // Handle other unknown error types\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return 'Unknown error occurred';\n    }\n  }\n\n  async listen(port: number, callback?: () => void): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      try {\n        this.server.listen(port, () => {\n          console.log(`HTTP/1.1 server listening on port ${port}`);\n          callback?.();\n          resolve();\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      try {\n        this.server.close((error?: Error) => {\n          if (error) {\n            reject(error);\n          } else {\n            console.log('HTTP/1.1 server closed');\n            resolve();\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  setRequestHandler(handler: (request: IRequest) => Promise<IResponse>): void {\n    this.requestHandler = handler;\n  }\n}\n","import * as http2 from 'http2';\nimport { HttpMethod, IRequest } from '../interfaces/IRequest';\nimport { IEngine } from '../interfaces/IEngine';\nimport type { IResponse } from '../interfaces/IResponse';\n\ninterface Http2Options {\n  key?: string | Buffer;\n  cert?: string | Buffer;\n  allowHTTP1?: boolean;\n  maxConnections?: number;\n  timeout?: number;\n}\n\nexport class Http2Engine implements IEngine {\n  public readonly protocol = 'HTTP/2';\n  public readonly isSecure = true;\n\n  private server: http2.Http2SecureServer | http2.Http2Server;\n  private requestHandler?: (request: IRequest) => Promise<IResponse>;\n\n  constructor(options: Http2Options = {}) {\n    // Default options for secure HTTP2\n    const defaultOptions: Http2Options = {\n      allowHTTP1: true, // Fallback to HTTP/1.1\n      maxConnections: 1000,\n      timeout: 30000,\n      ...options,\n    };\n\n    // Validate required SSL options for secure HTTP2\n    if (!defaultOptions.key || !defaultOptions.cert) {\n      this.server = http2.createServer();\n    } else {\n      this.server = http2.createSecureServer(defaultOptions);\n    }\n\n    this.setupStreamHandler();\n  }\n\n  private setupStreamHandler(): void {\n    this.server.on(\n      'stream',\n      async (stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) => {\n        try {\n          // Convert HTTP2 headers to framework IRequest\n          const request = await this.createRequestFromHeaders(headers, stream);\n\n          // Process request through framework handler\n          if (this.requestHandler) {\n            const response = await this.requestHandler(request);\n\n            // Send response back through HTTP2 stream\n            await this.sendResponse(stream, response);\n          } else {\n            // No handler configured, send 501\n            stream.respond({ ':status': 501 });\n            stream.end('Not Implemented');\n          }\n        } catch (error: unknown) {\n          console.error('HTTP2 Stream Error:', error);\n\n          // Type-safe error handling\n          const errorMessage = this.getErrorMessage(error);\n\n          stream.respond({ ':status': 500 });\n          stream.end(errorMessage);\n        }\n      }\n    );\n\n    // Handle server errors\n    this.server.on('error', (error: Error) => {\n      console.error('HTTP2 Server Error:', error);\n    });\n  }\n\n  private getErrorMessage(error: unknown): string {\n    if (error instanceof Error) {\n      return error.message;\n    }\n\n    if (typeof error === 'string') {\n      return error;\n    }\n\n    // Handle other unknown error types\n    try {\n      return JSON.stringify(error);\n    } catch {\n      return 'Unknown error occurred';\n    }\n  }\n\n  private async createRequestFromHeaders(\n    headers: http2.IncomingHttpHeaders,\n    stream: http2.ServerHttp2Stream\n  ): Promise<IRequest> {\n    // Extract HTTP2 pseudo-headers\n    const methodString = (headers[':method'] as string) || 'GET';\n    const path = (headers[':path'] as string) || '/';\n    const scheme = (headers[':scheme'] as string) || 'https';\n    const authority = (headers[':authority'] as string) || 'localhost';\n\n    // Convert string to HttpMethod\n    const method: HttpMethod = this.normalizeHttpMethod(methodString);\n\n    // Parse URL components\n    const url = new URL(`${scheme}://${authority}${path}`);\n\n    // Extract query parameters\n    const query: Record<string, string> = {};\n    url.searchParams.forEach((value, key) => {\n      query[key] = value;\n    });\n\n    // Extract route parameters (simplified - you'd want more sophisticated path parsing)\n    const params: Record<string, string> = {};\n\n    // Convert HTTP2 headers to standard format (HTTP2 uses lowercase)\n    const requestHeaders: Record<string, string> = {};\n    Object.entries(headers).forEach(([key, value]) => {\n      if (!key.startsWith(':') && typeof value === 'string') {\n        requestHeaders[key] = value;\n      }\n    });\n\n    // Parse body (HTTP2 streams are readable)\n    let body: unknown = undefined;\n    const chunks: Buffer[] = [];\n\n    return new Promise<IRequest>(resolve => {\n      stream.on('data', (chunk: Buffer) => {\n        chunks.push(chunk);\n      });\n\n      stream.on('end', () => {\n        if (chunks.length > 0) {\n          const rawBody = Buffer.concat(chunks).toString();\n\n          // Try to parse as JSON, fall back to raw string\n          try {\n            body = JSON.parse(rawBody);\n          } catch {\n            body = rawBody;\n          }\n        }\n\n        resolve({\n          method,\n          url,\n          path: url.pathname,\n          headers: requestHeaders,\n          query,\n          params,\n          body,\n          protocol: this.protocol,\n          remoteAddress: stream.session?.socket?.remoteAddress,\n          userAgent: requestHeaders['user-agent'],\n        });\n      });\n    });\n  }\n\n  private normalizeHttpMethod(method: string): HttpMethod {\n    const upperMethod = method.toUpperCase();\n\n    // Validate that it's a valid HttpMethod\n    const validMethods: HttpMethod[] = [\n      'GET',\n      'POST',\n      'PUT',\n      'PATCH',\n      'DELETE',\n      'HEAD',\n      'OPTIONS',\n      'TRACE',\n      'CONNECT',\n    ];\n\n    if (!validMethods.includes(upperMethod as HttpMethod)) {\n      throw new Error(`Unsupported HTTP method: ${method}`);\n    }\n\n    return upperMethod as HttpMethod;\n  }\n\n  private async sendResponse(stream: http2.ServerHttp2Stream, response: IResponse): Promise<void> {\n    // Convert framework IResponse to HTTP2 headers\n    const http2Headers: http2.OutgoingHttpHeaders = {\n      ':status': response.status || 200,\n      ...response.headers,\n    };\n\n    // Respond with headers\n    stream.respond(http2Headers);\n\n    // Send body if present\n    if (response.body !== undefined) {\n      if (typeof response.body === 'string') {\n        stream.write(response.body);\n      } else if (Buffer.isBuffer(response.body)) {\n        stream.write(response.body);\n      } else {\n        // Convert objects to JSON\n        stream.write(JSON.stringify(response.body));\n\n        // Set content-type if not already set\n        if (!response.headers['content-type']) {\n          stream.respond({ ':status': response.status || 200, 'content-type': 'application/json' });\n        }\n      }\n    }\n\n    // End the stream\n    stream.end();\n  }\n\n  async listen(port: number, callback?: () => void): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      try {\n        this.server.listen(port, () => {\n          console.log(`HTTP/2 server listening on port ${port}`);\n          callback?.();\n          resolve();\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      try {\n        this.server.close((error?: Error) => {\n          if (error) {\n            reject(error);\n          } else {\n            console.log('HTTP/2 server closed');\n            resolve();\n          }\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  setRequestHandler(handler: (request: IRequest) => Promise<IResponse>): void {\n    this.requestHandler = handler;\n  }\n}\n"],"mappings":"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","names":["url"]}